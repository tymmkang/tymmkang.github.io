[{
    "title": "윈도우 C++ 문자열 인코딩",
    "date": "2020-07-21",
    "description": "윈도우 환경에서 C++만을 사용하여 RESTful API를 사용해야하는 경우 인코딩이 문제가 될 수 있다. 이를 해결하기위한 함수를 포스팅한다.",
    "body": " C++ 문자열 인코딩 며칠 전 C++에서 HTTPS 리퀘스트를 송신해야 했었다.\n본인은 MSVC 멀티바이트 환경에서 구현했기 때문에. 필요했던 함수는 Multibyte, UTF-8 간 변환과, UTF-8 문자열을 URL 포맷에 맞도록 인코딩해주는 함수였다.\n Multibyte -\u0026gt; UTF-8 UTF-8 -\u0026gt; Multibyte UTF-8 -\u0026gt; URL format  구현된 함수에서 파라미터로 전달 된 std::string은 사실상 바이트 버퍼로 취급된다. 즉 std::string이라고 내부 버퍼에 1byte로 표현되는 문자들만 있는 것이 아니다. 이렇게 구현한 이유는 표준입출력을 통해 바로 콘솔에 출력하고 싶어서이다.\nMultibyte -\u0026gt; UTF-8 #include \u0026lt;string\u0026gt;#include \u0026lt;windows.h\u0026gt;// ... bool MB2U8(const std::string\u0026amp; mbStr, std::string* pRefU8Str) { size_t mbLen = ::MultiByteToWideChar(CP_ACP, 0, mbStr.data(), mbStr.size(), NULL, 0); if (mblen \u0026lt;= 0) return false; std::wstring ws(mbLen, 0); mbLen = ::MultiByteToWideChar(CP_ACP, 0, mbStr.data(), mbStr.size(), const_cast\u0026lt;wchar_t*\u0026gt;(ws.data()), mbLen); size_t u8Len = ::WideCharToMultiByte(CP_UTF8, 0, ws.data(), ws.size(), NULL, 0, NULL, NULL); if (u8Len \u0026lt;= 0) return false; pRefU8Str-\u0026gt;resize(u8Len, 0); u8Len = ::WideCharToMultiByte(CP_UTF8, 0, ws.data(), ws.size(), const_cast\u0026lt;char*\u0026gt;(pRefU8Str-\u0026gt;data()), u8Len, NULL, NULL); return true; } UTF-8 -\u0026gt; Multibyte #include \u0026lt;string\u0026gt;#include \u0026lt;windows.h\u0026gt;// ... bool U82MB(const std::string\u0026amp; u8Str, std::string* pRefMbStr) { size_t u8Len = ::MultiByteToWideChar(CP_UTF8, 0, u8Str.data(), u8Str.size(), NULL, 0); if (u8Len \u0026lt;= 0) return false; std::wstring ws(u8Len, 0); u8Len = ::MultiByteToWideChar(CP_UTF8, 0, u8Str.data(), u8Str.size(), const_cast\u0026lt;wchar_t*\u0026gt;(ws.data()), u8Len); size_t mbLen = ::WideCharToMultiByte(CP_ACP, 0, ws.data(), u8Len, NULL, 0, NULL, NULL); if (mbLen \u0026lt;= 0) return false; pRefMbStr-\u0026gt;resize(mbLen, 0); mbLen = ::WideCharToMultiByte(CP_ACP, 0, ws.data(), u8Len, const_cast\u0026lt;char*\u0026gt;(pRefMbStr-\u0026gt;data()), mbLen, NULL, NULL); return true; } UTF-8 -\u0026gt; URL format #include \u0026lt;string\u0026gt;#include \u0026lt;sstream\u0026gt;// ... std::string EncodeForURL(const std::string\u0026amp; value) { std::stringstream ss; char hexTemp[3]; unsigned char c = 0; for (size_t i = 0; i \u0026lt; value.size(); i++) { c = static_cast\u0026lt;unsigned char\u0026gt;(value[i]); if ((c \u0026gt;= \u0026#39;0\u0026#39;) \u0026amp;\u0026amp; (c \u0026lt;= \u0026#39;9\u0026#39;)) ss \u0026lt;\u0026lt; c; else if (c == \u0026#39; \u0026#39;) ss \u0026lt;\u0026lt; \u0026#39;+\u0026#39;; else if ((c \u0026gt;= \u0026#39;A\u0026#39;) \u0026amp;\u0026amp; (c \u0026lt;= \u0026#39;Z\u0026#39;)) ss \u0026lt;\u0026lt; c; else if ((c \u0026gt;= \u0026#39;a\u0026#39;) \u0026amp;\u0026amp; (c \u0026lt;= \u0026#39;z\u0026#39;)) ss \u0026lt;\u0026lt; c; else if ((c == \u0026#39;@\u0026#39;) || (c == \u0026#39;.\u0026#39;) || (c == \u0026#39;/\u0026#39;) || (c == \u0026#39;\\\\\u0026#39;) || (c == \u0026#39;-\u0026#39;) || (c == \u0026#39;_\u0026#39;) || (c == \u0026#39;:\u0026#39;))\tss \u0026lt;\u0026lt; c; else ss \u0026lt;\u0026lt; \u0026#39;%\u0026#39; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; (int)c; } return ss.str(); } ",
    "ref": "/blog/post_2020_07_21_00_%EC%9C%88%EB%8F%84%EC%9A%B0_c++_%EB%AC%B8%EC%9E%90%EC%97%B4_%EC%9D%B8%EC%BD%94%EB%94%A9/"
  },{
    "title": "테스트 포스팅",
    "date": "2020-07-20",
    "description": "Korean test",
    "body": "테스트 포스팅 테스트 용도의 포스팅입니다.\n",
    "ref": "/blog/post_2020_07_20_00_test/"
  },{
    "title": "About",
    "date": "2019-02-28",
    "description": "Hugo, the world’s fastest framework for building websites",
    "body": "Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n https://github.com/yuin/goldmark https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n",
    "ref": "/about/"
  },{
    "title": "Contact",
    "date": "0001-01-01",
    "description": "",
    "body": "",
    "ref": "/contact/"
  }]
